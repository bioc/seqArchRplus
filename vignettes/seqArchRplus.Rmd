---
title: "Downstream analysis of clusters of promoter sequence architectures with seqArchRplus"
author: "Sarvesh Nikumbh"
date: "`r Sys.Date()`"
package: seqArchRplus
output:
  BiocStyle::html_document:
      toc: true
vignette: >
  %\VignetteIndexEntry{Downstream analysis of clusters of promoter sequence architectures with seqArchRplus}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```


# Introduction


_seqArchRplus_ enables many steps in the downstream analyses of promoter 
sequence architectures. These are:

- Curate the final set of clusters from seqArchR. 
See the 
[`seqArchR` vignette](http://bioconductor.org/packages/release/bioc/vignettes/seqArchR/inst/doc/seqArchR.html)
, or the preprint to understand in detail why this may be required 

- Order the sequence architectures by the interquantile widths (IQWs) of the 
tag clusters (_aka_ promoter shape).
See 
[`CAGEr` vignette](https://www.bioconductor.org/packages/release/bioc/vignettes/CAGEr/inst/doc/CAGEexp.html) 
for more information on tag clusters

- Visualize distributions of IQW, TPM and conservation scores (or other when 
 available) per cluster

- Visualize the percentages of annotations for genome-wide CAGE-derived 
transcription tag clusters for each architecture-based clusters

- Ease of comparison across samples/stages: Visualize the above plots as 
(publication ready) combined panels

- Many per cluster visualizations including:
    - sequence logos of cluster architectures
    - strand-separated sequence logos of architectures
    - distributions of promoters on different chromosomes and strands
    - GO terms enriched for each architecture

- Produce BED track files of seqArchR clusters for visualization in a genome
browser or IGV

We hope that using seqArchRplus (together with seqArchR) will be useful in 
swiftly, but comprehensively, analyzing promoters identified using CAGE for 
any organism, and enable insights and hypotheses generation with ease. 
So far, we have tested seqArchR and seqArchRplus on promoters in drosophila 
(Schor et al. 2017 and modENCODE), zebrafish (Nepal et al. 2013), mice (Fantom),
humans (ENCODE), and also in plants (barley and maize).

We already envisage a feature for future version: generate HTML reports that help you navigate this wealth of information with ease.



# Installation

## When available on Bioconductor

```{r seqArchRplus-install, echo=TRUE, eval=FALSE}

## When available on Bioconductor
if (!require("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}

BiocManager::install("seqArchRplus")
```

## When available on GitHub


```{r install-from-github, echo=TRUE, eval=FALSE}
## From Github

if (!requireNamespace("remotes", quietly = TRUE)) {
    install.packages("remotes")
}

remotes::install_github("snikumbh/seqArchRplus", build_vignettes = TRUE)
```


In case of any errors or help required, please consider looking up:
[https://github.com/snikumbh/seqArchRplus](https://github.com/snikumbh/seqArchRplus)
and file a [new issue](https://github.com/snikumbh/seqArchRplus/issues/new).



# Using seqArchRplus for downstream analysis of promoter sequences

```{r setup-two, echo=TRUE}
# Load seqArchRplus
library(seqArchRplus)
library(seqArchR)
library(Biostrings)
library(TxDb.Dmelanogaster.UCSC.dm6.ensGene)
library(ChIPseeker)

# Set seed for reproducibility
set.seed(1234)
```

## Setting up

To analyse all transcription events/promoter sequences identified using CAGE 
data, the ideal setting for seqArchRplus is to use CAGEr first for pre-
processing the CAGE data, and subsequently use seqArchRplus to generate 
the numerous downstream visualisations. To begin with seqArchRplus, 
you need:

- the CAGEr object or information on the tag clusters from 
[https://bioconductor.org/packages/release/bioc/html/CAGEr.html](CAGEr), 
specifically, the width of the tag clusters, total TPM value of the cluster and 
that of the dominant CTSS in the cluster

- the seqArchR result object.


## Curating raw clusters from seqArchR result

Raw clusters from seqArchR result (say, the final iteration) often require 
curation. 

The seqArchR result does have a final `clustSol` (the clustering solution) 
where the clusters from the final iteration are collated. 
seqArchR uses hierarchical clustering for this purpose. 
However, hierarchical clustering, with a chosen agglomeration and distance 
method, does not necessarily output the best suitable collated set of clusters. 
Therefore, some small amount of manual curation (re-assignments) may be 
required to reach the ideal collated set of clusters as the final solution. 
This is achieved with the help of the `seqArchRplus::curate_clusters` function.

The basic idea of the curate_clusters function is available in 
`help(seqArchRplus::curate_clusters)`. 
A more elaborate description is as follows.
It takes as input an agglomeration method and also a distance method (see more 
arguments in help/documentation). 
On the first call to the function, a PDF file with the associated dendrogram 
resulting from the hierarchical clustering is shown together with the per 
cluster sequence logos. 
This should help in identifying if the chosen agglomeration and distance 
methods worked well (are clusters with similar sequence logos also together 
in the dendrogram?).
If this is satisfactory (chosen agglomeration and distance method have done 
well already and only few curations will be required), count the number of 
overall clusters that you can visually see. 
Generally, if (estimated) 3-4 (even 5-6) clusters out of 30-40 require 
curation, I would consider it as a satisfactory outcome from the hierarchical 
clustering output.
Now, in the second call to `curate_clusters`, specify the number of clusters 
based on your count.
View the resulting clustering in the new PDF file produced as output.
This time the dendrogram shows this clustering with colors and grey-scaled 
boxes drawn around the clusters.
Now you can exactly note which clusters need curation. 
Say, sequence clusters 39, 41 and 47 are combined into one, and sequence 
clusters 36-38 are combined into another cluster. 
Then, you may want to move sequence cluster 39 to the cluster of 36-38.
To do this, set the `need_change` argument of `curate_clusters` to `c(39)` and 
`change_to` argument to `c(36)`. 
Any one of the destination cluster members can be specified in `change_to`. 
Similarly, any other such curations can be added. 
Specify all such curations together in one go like this: 
`need_change <- list(c(39), c(24, 27), c(17))` and 
`change_to <- list(36, 21, 0)` -- sequence cluster 39 is moved to the cluster 
containing sequence cluster 36, 24 and 27 are moved to that of 21, and 17 to a 
totally new cluster of itself.

```{r curation-example, echo=TRUE, eval=TRUE}

## Using dummy sample names. Please replace with your sample names here

sample_names <- paste0("sample", 1:3)

sn <- "sample1"
use_aggl <- "complete"
use_dist <- "euclid"

use_dir <- tempdir()

seqArchR_result <- readRDS(system.file("extdata", "seqArchR_result.rds",
      package = "seqArchRplus", mustWork = TRUE))

## get seqArchR clusters custom curated
seqArchR_clusts <- seqArchRplus::curate_clusters(
    sname = sn,
    use_aggl = use_aggl, use_dist = use_dist,
    seqArchR_result = seqArchR_result, iter = 5,
    pos_lab = NULL, regularize = FALSE, topn = 50,
    use_cutk = 2, final = FALSE, dir_path = use_dir
)


## Suppose we identify K = 5 upon visual inspection.
set_cutk <- 5


## Form the lists need_change and change_to for re-assignments
need_change <- list(c(2))
change_to <- list(c(1))


seqArchR_clusts[[sn]] <- seqArchRplus::curate_clusters(
    sname = sn,
    use_aggl = use_aggl, use_dist = use_dist,
    seqArchR_result = seqArchR_result, iter = 5,
    use_cutk = set_cutk, #***

    need_change = need_change,
    change_to = change_to,
    final = FALSE, #***

    dir_path = use_dir
)

## Satisfied? now set final = TRUE
seqArchR_clusts[[sn]] <- seqArchRplus::curate_clusters(
    sname = sn,
    use_aggl = use_aggl, use_dist = use_dist,
    seqArchR_result = seqArchR_result, iter = 5,
    pos_lab = NULL, regularize = FALSE, topn = 50,
    use_cutk = set_cutk, #***
    need_change = need_change,
    change_to = change_to,
    final = TRUE, #***

    dir_path = tempdir()
)
## This fetches us clusters with custom/curated collation in _arbitrary_ order.
## See below for the function call to `order_clusters_iqw` that orders these 
## clusters by their median/mean interquantile width
```





## Generating individual plots via individual functions

One can use all the individual functions from seqArchRplus to generate all 
the plots.

```{r call-individual-functions, eval=TRUE, attr.source='.numberLines'}

# Dummy sample names
sample_names <- paste0("sample", 1:3)

raw_seqs <- Biostrings::readDNAStringSet(
    filepath = system.file("extdata",
        "example_promoters45.fa.gz",
        package = "seqArchRplus",
        mustWork = TRUE
    )
)

use_clusts <- readRDS(system.file("extdata", "example_clust_info.rds",
    package = "seqArchRplus", mustWork = TRUE
))



## Need a large text size because plots are large with high DPI value
## for production quality
use_txt_size <- 35

bed_info_fname <- system.file("extdata", "example_info_df.bed.gz",
    package = "seqArchRplus", mustWork = TRUE
)

info_df <- read.delim(
    file = bed_info_fname,
    sep = "\t", header = TRUE
)

tc_gr <- readRDS(system.file("extdata", "example_tc_gr.rds",
    package = "seqArchRplus", mustWork = TRUE
))


## get clusters ordered by median IQW values
seqArchR_clusts_ord <- seqArchRplus::order_clusters_iqw(
    sname = "sample1", clusts = use_clusts,
    info_df = info_df, order_by_median = TRUE
)
##
use_clusts <- seqArchR_clusts_ord
##
seqArchRplus::seqs_acgt_image(
    sname = "sample1",
    seqs = raw_seqs,
    seqs_ord = unlist(use_clusts),
    pos_lab = -45:45, dir_path = use_dir
)
##
seqArchRplus::write_seqArchR_cluster_track_bed(
    sname = "sample1",
    clusts = use_clusts,
    info_df = info_df,
    use_q_bound = FALSE,
    one_zip_all = TRUE,
    org_name = "OrganismName",
    dir_path = use_dir,
    include_in_report = FALSE,
    strand_sep = FALSE
)
##
iqw_tpm_pl <- seqArchRplus::iqw_tpm_plots(
    sname = "sample1",
    dir_path = use_dir,
    info_df = info_df,
    iqw = TRUE, tpm = TRUE, cons = FALSE,
    clusts = use_clusts,
    txt_size = use_txt_size
)


annotations_oneplot_pl <-
    seqArchRplus::per_cluster_annotations(
        sname = "sample1",
        clusts = use_clusts,
        tc_gr = tc_gr,
        cager_obj = NULL,
        qLow = 0.1, qUp = 0.9,
        txdb_obj = TxDb.Dmelanogaster.UCSC.dm6.ensGene,
        tss_region = c(-500, 100),
        orgdb_obj = NULL, dir_path = use_dir,
        one_plot = TRUE,
        txt_size = use_txt_size
    )

annotations_list_pl <-
    seqArchRplus::per_cluster_annotations(
        sname = "sample1",
        clusts = use_clusts,
        tc_gr = tc_gr,
        cager_obj = NULL,
        qLow = 0.1, qUp = 0.9,
        txdb_obj = TxDb.Dmelanogaster.UCSC.dm6.ensGene,
        tss_region = c(-500, 100),
        orgdb_obj = NULL, dir_path = use_dir,
        one_plot = FALSE,
        txt_size = 12
    )

seqlogos_oneplot_pl <-
    seqArchRplus::per_cluster_seqlogos(
        sname = "sample1",
        seqs = raw_seqs,
        clusts = use_clusts,
        pos_lab = -45:45, bits_yax = "max",
        strand_sep = FALSE, one_plot = TRUE,
        dir_path = use_dir,
        txt_size = use_txt_size
    )

## Obtain the sequence logos as a list for combining later
seqlogos_list_pl <-
    seqArchRplus::per_cluster_seqlogos(
        sname = "sample1",
        seqs = raw_seqs,
        clusts = use_clusts,
        pos_lab = -45:45, bits_yax = "max",
        strand_sep = FALSE, one_plot = FALSE,
        dir_path = use_dir,
        txt_size = 12
    )

stranded_seqlogos_pl <-
    seqArchRplus::per_cluster_seqlogos(
        sname = "sample1",
        seqs = raw_seqs,
        clusts = use_clusts,
        pos_lab = -45:45, bits_yax = "max",
        info_df = info_df,
        strand_sep = TRUE, one_plot = FALSE,
        dir_path = use_dir,
        txt_size = 12
    )

## Get larger flank FASTA sequences (larger than those used for seqArchR)
use_seqs <- Biostrings::readDNAStringSet(
    filepath = system.file("extdata",
        "example_promoters200.fa.gz",
        package = "seqArchRplus",
        mustWork = TRUE
    )
)


seqArchRplus::plot_motif_heatmaps(
    sname = "sample1", seqs = use_seqs,
    flanks = c(50, 100, 200),
    clusts = use_clusts,
    motifs = c("WW", "SS", "TATAA", "CG", "Y"),
    dir_path = use_dir,
    fheight = 800, fwidth = 1600
)

pair_colrs <- RColorBrewer::brewer.pal(n = 5, name = "Set3")

per_cl_strand_pl <- seqArchRplus::per_cluster_strand_dist(
    sname = "sample1",
    clusts = use_clusts,
    info_df = info_df,
    dir_path = use_dir,
    colrs = pair_colrs[4:5]
)
```

### Some additional notes

You may notice that the functions used in the above code block for generating 
individual plots take as input a cluster list. 
Here, we used the clusters upon first ordering them by their shape/IQWs (see 
how we define `use_clusts <- seqArchR_clusts_ord[[sn]]`, and then pass 
`use_clusts` to all functions.
Depending upon the use case, one may use arbitrarily ordered (any other order) 
clusters here. 
One can use these to look at their annotations, and if some clusters happen to 
to occur predominantly in 5' UTR or 3' UTR or exons or introns etc., such 
clusters can be sequestered from further downstream analyses.



## Generating all plots at once

You can let seqArchRplus generate all plots using default settings like so.

```{r generate-all-plots, eval=FALSE}

seqArchRplus::generate_all_plots(
    sname = "sample1",
    bed_info_fname = bed_info_fname,
    seqArchR_clusts = use_clusts,
    raw_seqs = raw_seqs,
    tc_gr = tc_gr,
    use_q_bound = FALSE,
    order_by_iqw = TRUE,
    use_median_iqw = TRUE,
    iqw = TRUE, tpm = TRUE, cons = FALSE,
    pos_lab = -45:45,
    txdb_obj = TxDb.Dmelanogaster.UCSC.dm6.ensGene,
    org_name = "Dmelanogaster",
    qLow = 0.1, qUp = 0.9,
    tss_region = c(-500, 100),
    raw_seqs_mh = use_seqs,
    motifs = c("WW", "SS", "TATAA", "CG"),
    motif_heatmaps_flanks = c(50, 100, 200),
    dir_path = tempdir(),
    txt_size = 25
)
```



# Conclusion

seqArchRplus enables many of the downstream analyses steps for studying the 
de novo identified sequence clusters/architectures using seqArchR or clusters 
obtained by any other clustering technique.
These promoter sequences can be identified using CAGE or variations of CAGE.


# Session Info
```{r session_info, include=TRUE, echo=TRUE, results='markup'}
sessionInfo()
```
